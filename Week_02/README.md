
## 哈希表、映射、集合的实现与特性

### Hash table

**哈希表也叫散列表**，是根据关键码值（key value）而直接进行访问的数据结构。

它通过把关键码值映射到表中一个位置来访问，以加快查找的速度。

这个映射函数叫散列函数（hash function），存放记录的数组叫哈希表（或散列表）。

- 工程实践
    1. 电话号码薄
    2. 用户信息表
    3. 缓存（LRU Cache）
    4. 健值对存储（redis）

Hash Table 平均是以 O(1) 的时间复杂度进行 删除、查询、插入 操作。

### 未整理
- 哈希碰撞
- 拉链式解决冲突法

## 树、二叉树、二叉搜索树的实现和特性

链表就是特殊化的树，因为有两个next指针。

树是特殊化的图，也就是说没有环的图就是树

### 二叉搜索树 binary Search Tree

二叉搜索树，也称为二叉排序树、有序二叉树（Ordered Binary Tree）、排序二叉树（Sorted Binary Tree），是指一颗空树或者具有下列性质的二叉树：

1. 左子树上==所有结点==的值小于它的跟节点的值；
2. 右子树上==所有结点==的值大于它的跟节点的值；
3. 以此类推：左、右子树也分别为二叉查找树。（这就是重要性！）

中序遍历：升序排序

- 二叉搜索树常见操作：
    1. 查询、插入和删除 O(log n)

### 问题：树的面试题解法为什么一般都是递归？
- 有明确的终止条件
- 树结构遍历没有办法进行有效的循环，递归是较为简单的操作（老师讲过的）
- 明显的重复子问题

### 二叉树的遍历
> 1. 前中后序遍历，简单看就是以遍历 根 的顺序划分，左右顺序不变； 
> 2. 树的遍历基本上都是基于递归，因为树结构没有办法进行有效的循环。递归操作较为简单。

```
1. 前序遍历(Pre-order)：根->左->右
def preorder(self, root):
  if root:
  self.traverse_path(root.val)
  self.preorder(root.left)
  self.preorder(root.right)
  
2. 中序遍历(In-order)：左->根->右
def inorder(self, root):
  if root:
  self.inorder(root.left)
  self.traverse_path(root.val)
  self.inorder(root.right)

3. 后序遍历(Post-order)：左->右->根
def postorder(self, root):
  if root:
  self.postorder(root.left)
  self.postorder(root.right)
  self.traverse_path(root.val)
```

## 堆、二叉堆和图
### 堆 heap

定义：可以迅速找到一堆数的最大或者最小值的数据结构。

将跟节点最大的堆叫做大顶堆或大根堆，根节点最小的堆叫做小顶堆或小根堆。

常见的堆有二叉堆、斐波那契堆等。

假设是大顶堆，则常见操作（API）：

- find-max:O(1)
- delete-max: O(logN)
- insert(create):O(logN) or O(1)

### 二叉堆
性质：
- 通过完全二叉堆来实现（注意：不是二叉搜索树）；
- 二叉堆（大顶）它满足下列性质：
    1. 是一颗完全树
    2. 树中任意节点的值总是>=其子节点的值；

实现细节：
- 二叉堆一般都通过“数组”来实现；
- 假设“第一个元素”在数组中的索引为0的话，则==父节点和子节点的位置关系==如下：
    1. 根节点（顶堆元素）是：arr[0];
    2. 索引为i的左孩子的索引是(2*i+1);
    3. 索引为i的右孩子的索引是(2*i+2);
    4. 索引为i的父结点的索引是floor((i-1)/2).

insert插入操作：
- 新元素一律先插入到堆的尾部；
- 依次向上调整整个堆的结构（一直到根即可）；

delete max 删除顶堆操作操作：
- 将堆尾元素替换到顶部（即对顶被替代删除掉）；
- 依次从根部向下调整整个堆的结构（一直到堆尾即可）：if > MAX(左、右子节点)? 交换 MAX 子节点

### 图
属性：
- Graph(V, E)
- V-vertex: 点
    1. 度 - 入度和出度
    2. 点与点之间：连通与否
- E-edge: 边
    1. 有向的无向（单行线）
    2. 权重（边长）

