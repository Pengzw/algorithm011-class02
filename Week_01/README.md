
### 数组、链表、跳表的基本实现和特性

#### 数组

数组==有连续的内存空间和相同类型的数据。== 正是有了这两个限制，才有了一个堪称杀手锏的特性：“随机访问”，但是==删除、插入一个数据，为了保证连续性，就需要做大量的数据搬移工作。==

==一维数据加速等概念通常采用的方式就是升维也就是变为二维数据。==


- 优点

1. 地址连续，访问任意一项都是常数级别O(1)；
- 缺点

1. 删除，增加元素时间复杂度高，需要遍历，一般为O(n)，插入前保证数组的size足够；
2. 数组size较小，会进行扩容，拷贝等低效的操作。


#### 链表
链表是一种物理存储结构上==非连续、非顺序的存储结构==，数据元素的==逻辑顺序是通过链表中的指针链接次序实现的==。

单链表，双向链表，循环链表(头尾相连,尾指针指向头指针)

- 优点

1. 灵活，插入不需要扩容、移动其他元素或者拷贝等操作，O(1)；
- 缺点

1. 占用内存，32系统一个指针4字节；
2. 遍历、查找不方便，必须挨个遍历，不能用下表访问，一般为O(n)。

#### 跳表

跳表是==对于链表的优化==，其中在Redis中应用广泛。

链表的访问速度比较慢，寻找一个元素需要挨个遍历，优化：==升维，空间换时间==

- 概念
1. ==跳表结合了链表和二分查找的思想==
2. 由原始链表和一些通过“跳跃”生成的链表组成
3. 第0层是原始链表，越上层“跳跃”的越高，元素越少
4. 上层链表是下层链表的子序列
5. 查找时从顶层向下，不断缩小搜索范围

注意：==只能用于元素有序的情况。所以，跳表（skip list）对标的是平衡树（AVL Tree）和二分查找，是一种插入／删除／搜索都是O（log n）的数据结构。== 1989年出现。

它最大的==优势是原理简单、容易实现、方便扩展、效率更高==。因此在一些热门的项目里用来代替平衡树，如redis、leveldb等。

- 跳表查询的事件复杂度分析

n/2、n/4、n/8、第k级索引结点的个数就是n/(2^k)。
假设索引有h级，最高级的索引有2个结点。n/(2^h)=2，从而求得h=log2（n）-1

- 缺点

1. 维护成本高，增加删除都需要更新索引；
2. 空间复杂度较高，O(n)

### 栈和队列的实现与特性
#### 栈 stack

1. 先入后出的容器结构；
2. 添加、删除皆为O(1)；因为无序的，所以查询是O(n)。

#### 队列 Queue

1. 先入先出的排队队列；
2. 添加、删除皆为O(1)；因为无序的，所以查询是O(n)。

#### 双端队列 deque

1. 栈和队列的结合体；
2. 头和尾都可以出入；添加、删除皆为O(1)；因为无序的，所以查询是O(n)。

#### 优先队列 Priority Queue（一种抽象的数据结构）

1. 插入操作O(1)；
2. 取出操作O(log n) 按元素的优先级取出；
3. 底层具体实现的数据结构较为多样和复杂：heap堆、bst二叉搜索树、treap

