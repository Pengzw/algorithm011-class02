## 启蒙篇
非科班出身，对算法还是比较陌生的，买了些书，自己折腾折腾，没什么感觉。。

看了redis源码，对优秀对写法吸取，则觉得代码工整、简洁、高大上，还有卧槽。。

现在嘛。。
### 让我们了解道算法有以下几种结构：

- 一维
    1. 基础：数组array（string），链表 linked list
    2. 高级：栈stack，队列queue，双端队列deque，集合set，映射map（hash or map），etc 
- 二维
    1. 基础：树tree，图graph
    2. 高级：二叉搜索树binary search tree（red-black tree，AVL），堆heap，并查集disjoint set，字典树trie，etc
- 特殊：
    1. 位运算bitwise，布隆过滤器bloomFilter
    2. LRU cache

### 对常见的复杂度的理解，会将所有系数置1:

1. O(1) 任意的输入，都执行相同的次数，那么就是O(1)，或常数复杂度 
2. O(logn n) 
3. O(n) 随着输入为n，执行n的相同倍数的次数，那么就是O(n)，或线性复杂度，比如一层for循环 
4. O(n^2) 随着输入为n，执行n^2的相同倍数的次数，那么就是O(n)，或线性复杂度，比如两层for循环 
5. O(n^3) 随着输入为n，执行n^3的相同倍数的次数，那么就是O(n)，或线性复杂度，比如三层for循环 
6. O(2^n) 比如直接求斐波拉契的函数 
7. O(n!) 在n非常大时，算法复杂度会让计算性能差别非常大； 


### 然后咱们如何衡量程序运行的效率
一些经验性的结论：

- 一个顺序结构的代码，时间复杂度是 O(1)。
- 二分查找，或者更通用地说是采用分而治之的二分策略，时间复杂度都是 O(logn)。这个我们会在后续课程讲到。
- 一个简单的 for 循环，时间复杂度是 O(n)。
- 两个顺序执行的 for 循环，时间复杂度是 O(n)+O(n)=O(2n)，其实也是 O(n)。
- 两个嵌套的 for 循环，时间复杂度是 O(n²)。


### 通用的优化方案：将“昂贵”的时间复杂度转换成“廉价”的空间复杂度
无论什么难题，降低复杂度的方法就是这三个步骤。只要你能深入理解这里的核心思想，就能把问题迎刃而解。

- 第一步，暴力解法。在没有任何时间、空间约束下，完成代码任务的开发。

- 第二步，无效操作处理。将代码中的无效计算、无效存储剔除，降低时间或空间复杂度。

- 第三步，时空转换。设计合理数据结构，完成时间复杂度向空间复杂度的转移。


### 一般在递归的情形下有这么四种在面试和工程中使用到：

1. 二分查找，一般发生在一个数列本身有序的时候，你要在有序的数列里找到你的目标数。只查一边这么下去的话，最后他的时间复杂度是log(n)。 

2. 如果是二叉树遍历的话，他的时间复杂度是O（n）。不通过主定理，简化的思考方式，二叉树遍历的话，我们会每一个节点都访问一次，而且仅访问一次。 

3. ==在一个排好序的二维矩阵中进行二分查找。时间复杂度是O（n）,如果是一维数组二分查找，时间复杂度是O(logn) ==

4. 归并排序（merge sort），时间复杂度是nlogn的时间复杂度。 

## 线性结构理解篇
### 数组、链表、跳表的基本实现和特性

#### 数组

数组==有连续的内存空间和相同类型的数据。== 正是有了这两个限制，才有了一个堪称杀手锏的特性：“随机访问”，但是==删除、插入一个数据，为了保证连续性，就需要做大量的数据搬移工作。==

==一维数据加速等概念通常采用的方式就是升维也就是变为二维数据。==


- 优点

1. 地址连续，访问任意一项都是常数级别O(1)；
- 缺点

1. 删除，增加元素时间复杂度高，需要遍历，一般为O(n)，插入前保证数组的size足够；
2. 数组size较小，会进行扩容，拷贝等低效的操作。


#### 链表
链表是一种物理存储结构上==非连续、非顺序的存储结构==，数据元素的==逻辑顺序是通过链表中的指针链接次序实现的==。

单链表，双向链表，循环链表(头尾相连,尾指针指向头指针)

- 优点

1. 灵活，插入不需要扩容、移动其他元素或者拷贝等操作，O(1)；
- 缺点

1. 占用内存，32系统一个指针4字节；
2. 遍历、查找不方便，必须挨个遍历，不能用下表访问，一般为O(n)。

#### 跳表

跳表是==对于链表的优化==，其中在Redis中应用广泛。

链表的访问速度比较慢，寻找一个元素需要挨个遍历，优化：==升维，空间换时间==

- 概念
1. ==跳表结合了链表和二分查找的思想==
2. 由原始链表和一些通过“跳跃”生成的链表组成
3. 第0层是原始链表，越上层“跳跃”的越高，元素越少
4. 上层链表是下层链表的子序列
5. 查找时从顶层向下，不断缩小搜索范围

注意：==只能用于元素有序的情况。所以，跳表（skip list）对标的是平衡树（AVL Tree）和二分查找，是一种插入／删除／搜索都是O（log n）的数据结构。== 1989年出现。

它最大的==优势是原理简单、容易实现、方便扩展、效率更高==。因此在一些热门的项目里用来代替平衡树，如redis、leveldb等。

- 跳表查询的事件复杂度分析

n/2、n/4、n/8、第k级索引结点的个数就是n/(2^k)。
假设索引有h级，最高级的索引有2个结点。n/(2^h)=2，从而求得h=log2（n）-1

- 缺点

1. 维护成本高，增加删除都需要更新索引；
2. 空间复杂度较高，O(n)

### 栈和队列的实现与特性
#### 栈 stack

1. 先入后出的容器结构；
2. 添加、删除皆为O(1)；因为无序的，所以查询是O(n)。

#### 队列 Queue

1. 先入先出的排队队列；
2. 添加、删除皆为O(1)；因为无序的，所以查询是O(n)。

#### 双端队列 deque

1. 栈和队列的结合体；
2. 头和尾都可以出入；添加、删除皆为O(1)；因为无序的，所以查询是O(n)。

#### 优先队列 Priority Queue（一种抽象的数据结构）

1. 插入操作O(1)；
2. 取出操作O(log n) 按元素的优先级取出；
3. 底层具体实现的数据结构较为多样和复杂：heap堆、bst二叉搜索树、treap

